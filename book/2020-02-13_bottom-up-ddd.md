# ドメイン駆動設計入門 ボトムアップでわかる！ドメイン駆動設計の基本

## Chapter2 システム固有の値を表現する「値オブジェクト」

### 2.3 値オブジェクトにする基準

- ドメインモデルとして挙げられている概念は、値オブジェクトにする。
- ドメインモデルとして挙げられていない概念は、値オブジェクトにするかどうかの正当性はコンテキストによる。
- 著者の基準は「そこにルールが存在しているか」と「それ単体で取り扱いたいか」
- 氏名の場合
  - 「姓と名で構成される」というルールがある
  - 単体で比較などをされる
- 値オブジェクトとして定義するほどの価値がある概念を実装中に発見した場合、それはドメインモデルとしてフィードバックすべき。
- これがドメイン駆動設計が目的とするイテレーティブな開発で、実装時の気付きにより支えられる。

### 2.4 ふるまいをもった値オブジェクト

- 値オブジェクトはデータを保持するコンテナではない
- 加算などのふるまいが定義されていることで、加算できるということがわかる
- ルール外のふるまいをしようとするとエラーを送出できる
  - 通貨単位が違う場合は例外となる
- 逆に定義されていないふるまいはできないという制約も可能

### 2.5 値オブジェクトを採用するモチベーション

- クラスを増やすことに抵抗を感じる開発者は多いため、値オブジェクトを採用するにはこの心理的ハードルを越える必要がある
- そのためのモチベーションを紹介
  - 表現力を増す
  - 不正な値を存在させない
    - 例外の送出処理をクラス内にまとめられる
  - 誤った代入を防ぐ
    - 自己文書化を進める（コードの正しさをコードで表現する）
    - UserIdにUserNameを代入できないようにする
  - ロジックの散在を防ぐ
    - ルールをクラス内に納められる

## Chapter3 ライフサイクルのあるオブジェクト「エンティティ」

### 3.1 エンティティとは

- 値オブジェクトとの違いは同一性によって識別されるか否か
- 年齢を重ねると人は別人になるか？⇒No
- つまり、属性が同じかどうかではなく、それ以外の何かで同一性が担保されている
- システム管理の文脈では、ユーザ情報を編集しても別のユーザになってしまうことはありえない

### 3.2 エンティティの性質

- 可変である
  - 値オブジェクトは交換により変更を表現していたが、エンティティはそのふるまい（関数）を使って属性を変更する
    - 無味乾燥なget, setも使わない方が良さそう
  - ただし全ての属性を可変にするわけではなく必要に応じて許可されているだけ（限りなく不変が良い）
  - 例外送出はあくまでセーフティネットであり、処理前にチェックすべき
- 同じ属性であっても区別される
  - 値オブジェクトは同じ属性を持っているとおなじものとして扱われるが、エンティティはそうではない
  - 同姓同名は同一人物ではない
  - 見分けるためには識別子UserIdなどが属性に必要
- 同一性を持つ
  - ユーザ名の変更前後で同じユーザとして認識して欲しいはず
  - そのためには識別子を使用して同一性を判断
  - 識別子は同一性の実体であり、その性質から可変にする必要はない
  - 同一性を比較するためのふるまいも必要
- 値オブジェクトでは、全ての属性が比較対象であったが、エンティティでは識別子だけが比較の対象となる

### 3.3 エンティティの判断基準としてのライフサイクルと連続性

- 何を値オブジェクトとし、何をエンティティとするか
- ライフサイクルが存在し、そこに連続性があるかは大きな判断基準
- ユーザは作成されて生を受け、削除されて死を迎える、ライフサイクルを持ち、連続性のある概念
- ライフサイクルや連続性がない、持たせることが無意味そうなオブジェクトは値オブジェクトにする
  - 極力不変なオブジェクトで構成することがセオリー

### 3.4 値オブジェクトとエンティティどちらにもなりえるモデル

- 全く同じ概念をさしていてもシステムによって異なる
  - 車にとってはタイヤはパーツであるため、交換可能であり、値オブジェクトでは
  - タイヤ工場にとっては個体を識別することは重要であり識別子をもつエンティティ

### 3.5 ドメインオブジェクトを定義するメリット

- コードのドキュメント性が高まり、ドメインにおける変更をコードに伝えやすくなる
- このメリットは製造工程よりも、保守開発で際立つ
- 仕様書は残念ながらマクロな要件について有効であり、ミクロな要件については無力であることが多い
- 質の悪いことにドキュメントはコードと異なり、記載内容が間違っていても動作しなくなるような問題は引き起こさない
- ルールがオブジェクトに記載されていない、無口なコードの場合、そこに存在する暗黙のルールが守られているかは全てのコードを洗い出す必要がある。
- これは熟練した開発者であっても多大な労力が必要
- また後からルール変更することも容易

### 3.6 まとめ

- もしエンティティを実装しようとしてそこにあいまいさを感じたのであれば、それはドメインの捉え方を見つめなおすきっかけ

## Chapter4 不自然さを解決するドメインサービス

### 4.1 サービスが指し示すもの

- ソフトウェア開発の文脈では、サービスはクライアントのためになにかを行うオブジェクト
- サービスは多様であり、ドメイン駆動設計においても、ドメインサービスとアプリケーションサービスがある

### 4.2 ドメインサービスとは

- 値オブジェクトやエンティティにふるまいを記述すると不自然となるものを、ドメインサービスで解決する
- 不自然な例
  - ユーザの重複確認

### 4.3 ドメインサービスの濫用が行き着く先

- ドメインオブジェクトが無口となり、クラス定義で意図を読み取ることが不可能となる
- この状態をドメインモデル貧血症という
- すべてのふるまいはドメインサービスに記述できるが、可能な限り避ける必要がある

### 4.4 エンティティや値オブジェクトと共にユースケースを組み立てる

- データストアへの問い合わせは眺めているだけでは意図をすぐには汲み取れない
- またこれらはRDBに依存しており、柔軟性に乏しい（NoSQLに変更を迫られるとコードの大半の変更が必要）
- これを解決するにはリポジトリというパターンが役立つ

### ドメインサービスの基準

- ドメインサービスは入出力を伴う処理を扱わないようにすべきという考えもあり、その意味ではこの実装は間違っている
- しかし筆者としては、可能な限り入出力をドメインサービスで扱わないようにする方針ではあるが、必要とあればいとわない
- より重要視していることは、その振る舞いがドメインに基づくものかそうでないかという点
- それを表現するために、インフラストラクチャのサービスの協力をえることは問題ない

### 4.5 物流システムに見るドメインサービスの例

- Ship, ReceiveはPhysicalDistributionBase(物流拠点を表すエンティティ)のふるまい
- 拠点間の輸送自体はドメインサービス

### 4.6 まとめ

## Chapter 5 データにまつわる処理を分離する「リポジトリ」

- リポジトリはオブジェクトの永続化や再構築を行う
- リポジトリとして分離することでデータストアを差し替え可能にし、テスト実行を容易とし、変更の難易度を下げることにつながる

### 5.1 リポジトリとは

- データの保管庫
- オブジェクトのインスタンスを保存したい場合は直接データストアに書き込みを行うのではなく、リポジトリにインスタンスの永続化を依頼
- 永続化したデータからインスタンスを再構築したい場合は、リポジトリにデータ再構築を依頼

### 5.2 リポジトリの責務

- コードの大半はデータストアの具体的なそうさとなるため趣旨が読み取りづらくなる
- このような具体的でややこしい処理を抽象化して扱うことで趣旨が分かりやすくなる

### 5.3 リポジトリのインターフェース

- インターフェースという抽象型で定義し、Save（永続化）、Find（再構成）などのふるまいをもつ。
- Exist（重複確認）などはリポジトリにやらせない、ユーザの重複確認はドメインのルールに近く、リポジトリは永続化と再構成のみの責務とする
- 「ユーザ名により重複確認をする」というドメイン知識が失われる
- ドメインサービスにインフラストラクチャに関わる処理を書きたくない場合は、重複確認のキーを引き渡すと、ドメイン知識が失われない

### 5.4 SQLを利用したリポジトリを作成

- ビジネスロジックに特定の技術基盤に依存した処理は書くべきではないが、リポジトリの実装は技術基盤に依存した処理を記述しても問題ない。

### 5.5 テストによる確認

- RDBを使ってテストをする場合、テーブルの準備などが煩雑、場合によっては前テストしたデータを削除するなどが必要
- これが極まるとテストをしなくなってしまう。
- 効率的にテストを行う仕組みが必要

### 5.6 テスト用のリポジトリを作成する

- メモリをデータストアとしてインメモリとして動作させる
- たとえば連想配列をベースとしたリポジトリを実装
- 基本的には永続化も再構成もディープコピーで行う（データストアが書き変わってしまうため）

### 5.7 ORMを用いたリポジトリの作成

- SQLを組み立てずORMを使う例

### 5.8 オブジェクトに定義されるふるまい

- 永続化（Save）
  - これはオブジェクト自体の永続化
  - 識別子と更新項目を引き渡して更新させるようなメソッドは適切ではない
  - 同様にオブジェクトを作成する処理もリポジトリには定義しない
- 削除（Delete）
- 再構築（Find）
  - 識別子が基本
  - 探索用に全件（FindAll）が合っても良いが慎重になる必要がある。
  - 探索する際にはそれぞれに適したメソッドがあると良い
    - FindByUserNameなど

### 5.9 まとめ

- 特になし

## Chapter6 ユースケースを実現するアプリケーションサービス

### 6.1 アプリケーションサービスとは

- ユースケースを実現するオブジェクト
- ドメインオブジェクトを組み合わせて実行するスクリプトのようなふるまい

### 6.2 ユースケースを組み立てる

- 一般的なCRUDが必要な例
- アプリケーションサービスのGetのreturnにそのままドメインオブジェクトを使用するかは重要な分岐点
  - ドメインオブジェクトを変更するふるまいを呼び出せてしまう
  - 無意味であるがそれは本質的な問題ではない
  - ドメインオブジェクトのふるまいを呼び出すのはアプリケーションサービスの役目であるべき
  - アクセス修飾子でドメインオブジェクトのメソッドの呼び出しを制限することもできますが、紳士協定になってしまう
- DTO
  - おすすめの方針は直接公開せず、データ転送用オブジェクト（DTO: Data Transfer Object）を使うこと
  - DTOがコンストラクタでドメインオブジェクト（エンティティ）を受け取ることは問題ない
- コマンドオブジェクト
  - メソッドのシグネチャの変更を避けるために使用する戦術

### エラーかそれとも例外か

- 処理が失敗した時にエラーを返却するか例外を送出するかは、議論に値するテーマ

### 6.3 ドメインのルールの流出

- アプリケーションサービスにはドメインのルールを記述されるべきではない
- 例：ユーザの重複確認
  - 点在していると、重複と判断するルールの変更に対処が大変となる
- ドメインのルールはドメインオブジェクトに記述する
- 上記の例では、ドメインサービスに記述する

### 6.4 アプリケーションサービスと凝集度

- 凝集度とはモジュールの責任範囲がどれだけ集中しているか
- 指標としてLCOM（Lack of Cohesion in Method）というものがある
  - 端的に言うと全てのインスタンス変数は全てのメソッドで使われるべき、という指標
- 凝集度を高くすることが常に正解ではないが一考の価値がある尺度
- 具体的に凝集度を高くするには処理毎にクラスを分ければよい
- その場合、まとまりがなくなるためパッケージ上は近くに置くことが良い

### 6.5 アプリケーションサービスのインターフェース

- アプリケーションサービスのモックを準備することができる
- また例外を送出するテストに特化したアプリケーションサービスなども準備可能

### 6.6 サービスとは何か

- サービスは物事ではなく、活動や行動であることが多い
- サービスには状態を持たせない
  - 状態を一切持たないことは意味しない
  - 現に、UserApplicationServiceはIUserRepositoryを状態として持つ
  - ただし、その状態により処理が分岐したりせず、直接的にはサービスのふるまいを変更しない

### 6.7 まとめ

## Chapter7 柔軟性をもたらす依存関係のコントロール

### 7.1 技術要素への依存がもたらすもの

- オブジェクト同士の依存は避けられない。重要なのは依存を避けることではなくコントローすること

### 7.2 依存とは

- 参照による依存関係
  - ObjectA内にObjectBのインスタンス変数があるときなど
  - この場合、ObjectAからObjectBに矢印が向く
- 汎化による依存関係
  - UserRepositoryからIUserRepositoryへの依存など
  - この場合、UserRepositoryからIUserRepositoryに白抜きの矢印が向く
- 抽象型を使用し、具象型に向いていた依存関係の矢印が抽象型に向くようにする
- このように全てのモジュールが抽象へ依存するように制御することは、ビジネスロジックを具体的な実装から解き放ち、より純粋なものにする効果がある
- この抽象型を用いた依存関係の制御は「依存関係逆転の法則」と呼ばれている

### 7.3 依存関係逆転の原則

- 定義
  - 上位レベルのモジュールは下位レベルのモジュールに依存してはならない、どちらのモジュールも抽象に依存すべき
  - 抽象は、実装の詳細に依存してはならない、実装の詳細が抽象に依存すべき
- インターフェースはそれを利用するクライアントが宣言するものであり主導権はそのクライアントにある
- インターフェースを宣言し低レベルのモジュールはそのインターフェースに合わせて実装を行うことで、より上位のモジュールに主導権を握らせる

### 7.4 依存関係をコントロールする

- IUserRepositoryをインスタンス変数にしていても、クラス内でその実装をインスタンス化してIUserRepositoryに与えるのは意味がない
- 具象クラスを内部でインスタンス化しているため、詳細なオブジェクトに依存してしまっている
- これを解決するためには、ServiceLocatorとIoC Containerというパターンがある

#### Service Locator

- Service Locatorと呼ばれるオブジェクトに依存解決先となるオブジェクトを事前に登録しておく
- インスタンスが必要となる各所でService Locator経由でインスタンスを取得する
- 事前登録はスタートアップスクリプトなどで実施
- この事前登録をプロダクションとテストで分けて一括管理すると便利
- 導入しやすい一方で、アンチパターンとも言われている。理由は外部から依存関係が見づらくなったり、テストの維持が難しくなることが挙げられる

#### IoC Container

- Dependency Injection
  - Dependency Injectionというパターンについて知る必要がある
  - 今まで出てきているものはコンストラクタインジェクションで、これ以外にメソッドインジェクションなどの多くのパターンがある
  - ただしこれにはインスタンス化するあちこちで記述する必要性がある
  - これを解決するにはIoC Containerパターンを使う
- IoC Container
  - C#ではServiceCollectionを使って、依存解決の設定を登録
  - serviceCollectionのBuildServiceProviderでproviderを作成
  - provider.getServiceでUserApplicationServiceをGenericに指定すれば、コンストラクタの依存関係をServiceCollectionに基づいて解決してくれる
- 疑問
  - Service Locatorで得たuserRepositoryをコンストラクタに与えたらいかんのかな？と思ってしまった
  - 依存するものが増えて、コンストラクタの引数が増えたときにめんどいってことか？それはたしかに

### 7.5 まとめ

- 特になし

## Chapter8 ソフトウェアシステムを組み立てる

### 8.1 ソフトウェアに求められるユーザインターフェース

- Web GUIでもCLIでもドメイン駆動設計の恩恵を受けられる

### 8.2 コマンドラインインターフェースに組み込んでみよう

- シングルトンはインスタンスを全体で使いまわす
- 例ではImMemoryUserRepositoryのみシングルトンにしている

### 8.3 MVCフレークワークに組み込んでみよう

- ASP.NETが分からないので正直完全な理解は難しい
- 他のフレームワークで置き換えて理解する必要がある
- コンストラクタで依存性の解決がされている
- ビジネスロジックをアプリケーションサービスに寄せることで、コントローラとしてのコードはほとんど同じような記述にシンプルなものとなる点はポイント

### コントローラの責務

- コントローラの責務は入力の変換をしてモデルに伝えること（ゲーム機のコントローラの電気信号への変換と同じ）
- コントローラがそれ以上のことをこなしている場合は、ドメインの重要な知識やロジックがコントローラに漏れだしている可能性を疑うべき

### 8.4 ユニットテストを書こう

- 結果の確認に必要なアクセスをリポジトリが提供しているとは限らないため、テスト用のImMemoryRepositoryはリポジトリのプロパティを直接操作可能にしておくとよい。
- ドキュメントが一切存在しないプロダクトにおいては、ユニットテストがそのロジックのあるべき姿を語る最後の手がかり

### 8.5 まとめ

- 特になし

## Chapter9 複雑な生成処理を行う「ファクトリ」

- オブジェクトを生成する責務を負ったオブジェクト

### 9.1 ファクトリの目的

- 複雑な道具はその生成過程も複雑
- 複雑なオブジェクトの生成処理をオブジェクトとして定義する

### 9.2 採番処理をファクトリに実装した例の確認

- 採番をシーケンスにする
- これをUserオブジェクトに定義するにはデータベースへのアクセスが必要なため望ましくない
- ファクトリにすることで、Userオブジェクトのインスタンスが新規作成と再構成で２種類あったものが、必ずUserIdが必要となるので一つにまとめることも可能になる
- Repository同様にRDBにアクセスしないインメモリのファクトリも需要がある（よってInterfaceで実装することが望ましい）
- RDBは自動採番機能を実装していることがあり強力だが、以下のような課題がある
  - 永続化を行うまで識別子が存在しないことになる
  - UserのIdプロパティがリポジトリから操作できる必要があり、開発者側でIDを付け替えることも可能となってしまう
  - 開発者に暗黙の了解を課す
- 採番処理をリポジトリのコードに課すパターンもあるが、筆者の感覚では採番処理まで手を伸ばすのは責務を広げすぎている印象

### ファクトリの存在に気付かせる

- Userクラスをみてもファクトリの存在に気づけない
- そのため、同じパッケージ配下に置いておくことがポイント

### 9.3 ファクトリとして機能するメソッド

- UserオブジェクトでCreateCircleをする例
- UserのIdを内部で使用することで、ゲッターを使わずに実現できる
- これが良いかはドメインの捉え方により、ユーザがサークルを生成することをドメインオブジェクトのふるまいとして定義するべきであれば正当化される

### 9.4 複雑な生成処理をカプセル化しよう

- ポリモーフィズムの恩恵を受ける以外に、単純に複雑なインスタンスを構築する処理をまとめるためにファクトリを使用するのも良い
- 本来は初期化はコンストラクタの役割だが、コンストラクタは単純である必要があり、単純でなくなる場合はファクトリを定義する
- コンストラクタで他のオブジェクトを生成するかどうかはファクトリを作る際の指標
- ファクトリを必ず使用すべきという意味ではないが、ファクトリを導入すべきか検討する習慣をみにつけるべき

### ドメイン設計を完成させるために必要な要素

- ファクトリやリポジトリはドメイン由来ではないが、ドメインを表現するために必要な要素

### 9.5 まとめ記事を書く際には参考になりそうなひとつ

- 特になし

## Chapter10 データの整合性を保つ

- トランザクションをどのように取り扱うか

### 10.1 整合性とは

### 10.2 致命的な不具合を確認する

- 例. 同一のユーザ名の登録処理が同時に実行される場合

### 10.3 ユニークキー制約による防衛

- データベースでユニークキー制約を掛ける
- 副作用として、コードの表現力が失われる可能性がある（重複チェックがコードから見えなくなる）
- また、特定の技術基盤に依存している
- ユニークキー制約はルールを守る主体ではなくセーフティーネットとして活用されるべき
- ユニークキー制約があるからと言って、コードの重複確認を省くべきではない

### 10.4 トランザクションによる防衛

- コミットするまでデータ処理が確定されない
- Connectionというオブジェクトへの依存がUserApplicationServiceに発生してしまう問題
- そもそも整合性は特定の技術基盤に根差す概念ではないため、C#として準備されている高次元なTransactionScopeを使う
- Javaの場合は@Transactionalアノテーション
- ユニットオブワークという手段も

### 結局どれをつかうべきか

- C#以外ならAOPで、@Transactionalに相当する機能が無い場合はその仕組みを作成する

### 10.5 まとめ

- 特になし

## Chapter11 アプリケーションを１から組み立てる

### 11.1 アプリケーションを組み立てるフロー

- 例
  - 最初に確認することは、どういった機能が求められているか
  - 機能を実現するためのユースケースの洗い出し
  - ユースケースを実現するにあたっての、必要な概念やルールからアプリケーションが必要とする知識を選び、ドメインオブジェクトを準備
  - このドメインオブジェクトを用いてユースケースを実現するアプリケーションサービスを作成

### 11.2 題材とする機能

- サークル機能
- ユースケース
  - サークルの作成
  - サークルへの参加

### 11.3 サークルの知識やルールをオブジェクトとして準備する

- 特になし

### 11.4 ユースケースを準備する

- 「メンバー数を30人まで」というドメインルールをアプリケーションサービスに記述しないようには、集約という考え方が必要

### 11.5 まとめ

- 実践を繰り返すことが重要

## Chapter12 ドメインのルールを守る「集約」

### 12.1 集約とは

- 不変条件を維持する単位として切り出され、オブジェクト操作に秩序をもたらす
- 集約には境界とルートが存在する
  - 外部からの集約に対する操作はルートを経由して行われる
- 集約は既に出てきている
  - Userがルート、その集約にUserId、UserNameが含まれる
  - Circleも同様に集約することで、ルールをまとめられる
  - 外部からの呼び出しもより直接的に
- オブジェクト指向では、外部から内部のオブジェクトを直接操作するのではなく、それを保持するオブジェクトに依頼する形をとる
- そうすることで直感的に、かつ不変条件の維持が可能（デメテルの法則）
- デメテルの法則によると、メソッドを呼び出すオブジェクトは以下の４つに限定
  - オブジェクト自身
  - 引数として渡されたオブジェクト
  - インスタンス変数
  - 直接インスタンス化したオブジェクト
- オブジェクトのフィールドのオブジェクトのメソッドを呼び出してはならない
- 完全にpublicを禁止とすると、Repositoryなどでインスタンスを永続化する際に困る
- 開発者間で制約を課しても良いがこれは強制力が弱い
- これに対する対策として、通知オブジェクトを使用する方法がある
  - しかしコード量が増えるため、
- Scalaにはきめ細やかなアクセス修飾子が存在し、Repositoryだけに限定してアクセスを許すことが可能

### 12.2 集約をどう区切るか

- 集約をどう区切るかは難しいテーマだが、その方針としてメジャーなのは「変更の単位」
  - サークルを変更する時はサークルの集約内部で納める
  - ユーザを変更する時はユーザの集約内部で納める
- 悪い例
  - サークルが持つMembers（ユーザのコレクション）の一つのユーザ名を変更
  - サークルの永続化時には、ユーザの更新処理に汚染される
- このことからリポジトリも変更の単位である集約毎に用意する
- これを回避するためにサークル集約に、ユーザ集約を直接保持するのではなく、識別子をインスタンスの代わりに保持する方法がよい

### IDのゲッターに対する是非

- getterは可能な限り排除すべきものだが、識別子はエンティティを表現するシステム的な属性でそれ自体が集約の代わりとして使用可能な便利なもの
- そのため識別子を公開することでデメリットよりメリットが大きいこともある

### 12.3 集約の大きさと単位

- トランザクションはデータをロックするため、集約はなるべく小さく保つべき
- 大きな集約が出来上がってしまった場合は、境界線を見つめなおすチャンス
- また複数の集約を同一トランザクションで操作することも可能な限り避ける

### 結果整合性

- 特になし

### 12.4 言葉との齟齬を消す

- 29を30にする話

### 12.5 まとめ

- 集約はシステマティックに定義することは難しい
- 概念はそのほとんどが連なっており、境界線を引くことは簡単ではない
- 境界線を引くことはドメインの概念を捉え、そこにある不変条件を導出し、ドメインとシステムを両天秤に掛けながら最適化するような作業
- バランスの取れた解を目指す

## Chapter13 複雑な条件を表現する「仕様」

### 13.1 仕様とは

- 仕様の例
  - メンバーが30人に達しているかを確認する isFull など
  - このような簡単な例の場合は、サークルオブジェクトのメソッドとして実装すればよいが、条件が複雑となると難しくなってくる
- 難しい例
  - ユーザのタイプにより制限が変わる（例：プレミアムユーザ）
  - ドメインのルールなので、アプリケーションサービスとして実装するのも不適切
  - Circleオブジェクトに実装する場合は、ユーザの識別子のコレクションしか持っていない場合、UserRepositoryが必要になってしまう
- Specificationクラス
  - 解決策として仕様として切り出して別のクラスとする
  - 仕様はれっきとしたドメインオブジェクト
  - そのため、Repositoryを使用することを避ける考えもある
- ファーストクラスコレクション
  - 実現方法はファーストクラスコレクションという、これに特化した集合オブジェクトを用意する（汎用的なListなどを使用しない）
  - このコレクションは、識別子だけではなく、所属するメンバーをすべて保持する
  - ファーストクラスコレクションを使う場合は、アプリケーションサービスでデータの詰め替えを行う

### 13.2 仕様とリポジトリの組み合わせ

- 例 : おすすめのサークルの検索
  - リポジトリに定義するのは悪い例。オススメ条件は重要なドメインルールであり、リポジトリの実装クラスに左右されてはならない
  - こういったものもできるかぎりドメインのオブジェクトとして表現すべき
  - 仕様をinterfaceとして、リポジトリに渡すことも考えられる
- パフォーマンスへの影響
  - 仕様をリポジトリに引き渡す方法はオブジェクトを生成して仕様に引き渡して検査する必要がある
  - 結果として全件検索が必要なので、パフォーマンスが課題となる
  - この場合は仕様やリポジトリを敢えて使用しないことも選択肢になりうる
- 最適化のために直接クエリを実行する
  - ドメインの防衛を理由に利用者に対して不便を強いるのは正しい道ではない
  - 読み取りで要求されるデータは複雑だが、その動作は単純でドメインのロジックはほとんどない
  - 反対に書き込みはドメインとしての制約が多い
  - これらのことからクエリにおいてはある程度制約を緩和することがある
  - この考えはCQS(Command-query separation)やCQRS(Command Query Responsibility Segregation)と呼ばれる

### 遅延実行による最適化

- 遅延実行は強力な手段だが、特定の技術基盤への依存が悩ましい

### 13.3 まとめ

- 特になし

## Chapter14 アーキテクチャ

- アーキテクチャは知識を記述すべき個所を示す方針
- ドメインのルールが流出することを予防し、同時に一か所にまとめることを促す

### 14.1 アーキテクチャの役目

- DDDにとってアーキテクチャは決して主役ではない
- アンチパターン：利口なUI
  - ドメインオブジェクトに記載されるべきルールがUIに記述されてしまっている状態
  - UIはできるだけ愚かであるべき
- 例：ECサイトの合計金額計算の処理
  - 真に問題となるのは最初の時点で画面が１つしかなかった時
  - 複数の場所で計算することが頭をよぎるものの、その時が来れば実施すればよいと楽観的になってしまう
- いま開発しているソフトウェアが単純なものであるという先入観を捨てることから始めるべき
- ビジネスロジックを正しい場所に配置し続けることは、その大切さを熟知していても難しい
- それを解決するのがアーキテクチャ
- アーキテクチャに従ったからと言ってDDDを実践したことにはならない

### 14.2 アーキテクチャの解説

#### レイヤードアーキテクチャ
- プレゼンテーション層（ユーザーインターフェイス層）
  - UIとアプリケーションを結びつけ、表示と解釈を責務とする
  - 結びつけるのであれば、WebフレームワークであってもCLIであってもよい
  - コントローラはプレゼンテーション層に所属する
- アプリケーション層
  - アプリケーションサービスなど
  - ドメインオブジェクトの直接のクライアントとなり、ユースケースを実現するためにまとめる役割
- ドメイン層
  - 最も重要な層で問題解決に必要な知識を提供
- インフラストラクチャ層
  - 技術的基盤へのアクセスを提供する層
  - メッセージ送信やドメインの永続化など
- 本書の実装はレイヤードアーキテクチャを意識していた

#### ヘキサゴナルアーキテクチャ

- コンセプトはアプリケーションとそれ以外のIFや保存媒体は付け外しができるようにするというもの
  - ゲーム機は良いたとえ
- プライマリーポート・プライマリーアダプタ
  - アプリケーションへの入力を受けもつ
- セカンダリーポート・セカンダリーアダプタ
  - アプリケーションが外部に対してインタラクトする部分
- 例：アプリケーションサービスのユーザ更新処理
  - Updateメソッドを呼び出すクライアントがプライマリアダプタ
  - Updateメソッド自体をプライマリポート
  - IUserRepositoryがセカンダリポート
  - IUserRepositoryの実装がセカンダリアダプタ
- レイヤードアーキテクチャではインターフェイスを利用するかは任意だが、ヘキサゴナルではこれに言及して依存関係を整理している
- とはいえ昨今のシステム開発ではレイヤードアーキテクチャもインターフェースを利用することが当たり前であるため垣根はあまりない

#### クリーンアーキテクチャ

- 4つの同心円で表される
- クリーンアーキテクチャのエンティティはDDDのエンティティを示さずどちらかというとドメインオブジェクトに近い概念
- クリーンアーキテクチャはUIやデータストアなどの詳細を端に追いやり依存関係を逆転させることで、詳細が抽象に依存する依存関係逆転の原則を達成する
- めざすコンセプトはヘキサゴナルと同じ
- コンセプトを実現するための具体的な方針が明示されている
- これまでのアプリケーションサービスと異なる点
  - 出力する先がpresenterと呼ばれるオブジェクトとなっている点

### 14.3 まとめ

- 特になし

## Chapter15 ドメイン駆動設計のとびらを開こう

- 今後の学習の手引き

### 15.1 軽量DDDに陥らないために

- 軽量DDDはコードの書き方を主題としており、開発者だけで完結してしまう。
- しかしドメイン駆動設計が目指すのはパターンに終始することではなく、ドメインの本質に向き合うこと
- パターンは見るものすべてを釘に変えてしまう魔力がある

### 15.2 ドメインエキスパートとモデリングをする

- 認識のずれ
  - 開発者がシステム開発に実直な言葉を使うほど、ドメインのエキスパートは開発はシステム開発のエキスパートに任せる方がよさそうだと理解を放棄してしまう
  - 最終的にドメインとコードの断絶という結果に行きつく
- 開発者はドメインのエキスパートと会話をしなければならない
  - ドメインのエキスパートはドメインの実践者であり、決してステークホルダーのことではない
  - ドメインのことを知るには彼らが所属している世界がどんなものなのか、見える景色がどういうものか、システマチックな表現に変換することよりも、ドメインの概念を捻じ曲げないように共通の言葉でコミュニケーションを心がけるべき
  - 開発者はドメインと向き合うことよりも、技術的なアプローチに傾倒しがちだが、それは間違った選択肢
- ドメインエキスパートへ迎合するように推奨しているわけでない
  - 彼らが認識している問題は実は些細で、本当に解決すべき問題は全く別のところにあることもある
  - 真に解決すべき問題は開発者とドメインエキスパートが対話することにより見つけ出される
  - そもそもドメインエキスパートはドメインモデルを知っているわけではない
  - 人間は自分が欲しいものについて案外理解していない
  - 必要とあればシステムを理解するために必要なことを教え、双方向の対話を通して知識を蒸留する
- プロダクトオーナやステークホルダーへのアドバイス
  - ソフトウェアを利用する当事者に対するインタビューをステークホルダーを通じて行うと、価値あるドメインモデルはできない
  - プロジェクトを成功させたいならばドメインエキスパートと開発者の仲介をするのではなく、会話の機会を増やすよう働きかける
- ドメインとコードを結びつけるモデル
  - モデルが設計と断絶していると、フィードバックしてドメインモデルを成長させる機会を失う

### 15.3 ユビキタス言語

- ドメインエキスパートと同じ言葉で会話をする必要がある
- その言葉とコードに乖離が大きいと、すぐに修正ができずコードを吟味するところから始めなくてはならず、それが積み重なって膨大なコストとなる
- プロジェクトの共通言語のことをユビキタス言語といい、あらゆるところで使用される必要がある
  - ドメインエキスパートの会話
  - 開発者同士の会話
  - ソースコード
- 会話をするうちに言葉の定義が不正確で合ったり曖昧であることが発覚した場合にはお互いに指摘しあい、より適した表現に改良する
- 例：ユーザの名前を変更する
  - ChangeNameでありUpdateNameではない

### ユビキタス言語と日本語の問題

- 英訳が妥協案

### 15.4 境界付けられたコンテキスト

- サークルなどに所属するユーザとシステム上のユーザは同じ単語でありながらその背景や目的が全く異なる
- 前者にはパスワードという概念はなく、視点が変わると着目すべき内容が変わる
- これは定義が揺れていることを意味しておらず、複数のコンテキストの境界に立っている
- こういう場合は無理に統一せず別のオブジェクトとして定義してしまう方が素直
- システムが大規模になるほど、統一したモデルを作ることは現実的ではない、統一するとしがらみの多いオブジェクトができ、変化に対応できなくなる
- 別オブジェクトでも識別子は共通である必要がありそう？

### 15.5 コンテキストマップ

- 識別子を別のもの（たとえばユーザ名など）にする場合、変更はそのコンテキスト内にとどまらず他のコンテキストにも影響がある
- この場合に、併せて変更が反映されるよう、コンテキスト同士の関係を定義し、ドメイン全体を俯瞰できるようなものとしてコンテキストマップが必要
- ２つのチームをつなぐ梯はテスト

### 15.6 ボトムアップドメイン駆動設計

- 作るものありきではなく、まずは問題を紐解くことから始めるアプローチはまさにボトムアップ
- ある知識を得るためには前提となる知識が必要となることは多い、ボトムアップに知識を積み上げていけば必ずや理解へと到達する

### 15.7 まとめ

- 特になし

## Appendix ソリューション構成

### A.1 ソフトウェア開発の最初の一歩

- パッケージ構成について言及
- 複数形は言語仕様（クラス名とパッケージ名が衝突してはならない）が許さない場合で、通常は単数形でよい
- FactoriesやRepositoriesはつくらない。カッターと包丁は同じ場所にしまわない。
- パッケージを分ける際は属性に着目せず意味的なまとまりを意識する
- FactoryやRepository、仕様はドメインオブジェクトと同居する
- ドメインサービスは複数のドメインオブジェクトを操作することがあるため、中立的に配置する
- Domain構成例

```
- Domain
  - Models
    - Circles
      - Circle
      - CircleId
      - CircleName
      - ICircleRepository
      - RecommendedCircleSpecification
    - Users
      - User
      - UserId
      - UserName
      - IUserRepository
      - IUserFactory
  - Services
    - UserService
  - Shared
    - ISpecification
```

- Application構成例

```
- Application
  - Circles
    - CircleApplicationService
    - CircleGetCommand
    - CircleCreateCommand
    - CircleGetResult
    - CircleData
  - Users
    - UserApplicationService
    - UserGetCommand
    - UserCreateCommand
    - UserGetResult
    - UserData
```

- インフラストラクチャの構成例

```
- EF (※EntitiyFrameworkの略)
  - Circles
    - EFCircleReposoitory
  - Users
    - EFUserRepository
    - EFUserFactory
- InMemory
  - Circles
    - InMemoryCircleReposoitory
  - Users
    - InMemoryUserRepository
    - InMemoryUserFactory
```

### A.2 ソリューション構成

- いわゆるVisual Studioのプロジェクト分割の話なので詳細割愛

### A.3 まとめ

- 特になし


---
2023-04-24 : 51/341 (15.0%)
2023-05-02 : 79/341 (23.2%)
2023-05-03 : 108/341 (31.7%)
2023-05-04 : 171/341 (50.1%)
2023-05-05 : 199/341 (58.4%)
2023-05-06 : 341/341 (100.0%)
