# ドメイン駆動設計入門 ボトムアップでわかる！ドメイン駆動設計の基本

## Chapter2 システム固有の値を表現する「値オブジェクト」

### 2.3 値オブジェクトにする基準

- ドメインモデルとして挙げられている概念は、値オブジェクトにする。
- ドメインモデルとして挙げられていない概念は、値オブジェクトにするかどうかの正当性はコンテキストによる。
- 著者の基準は「そこにルールが存在しているか」と「それ単体で取り扱いたいか」
- 氏名の場合
  - 「姓と名で構成される」というルールがある
  - 単体で比較などをされる
- 値オブジェクトとして定義するほどの価値がある概念を実装中に発見した場合、それはドメインモデルとしてフィードバックすべき。
- これがドメイン駆動設計が目的とするイテレーティブな開発で、実装時の気付きにより支えられる。

### 2.4 ふるまいをもった値オブジェクト

- 値オブジェクトはデータを保持するコンテナではない
- 加算などのふるまいが定義されていることで、加算できるということがわかる
- ルール外のふるまいをしようとするとエラーを送出できる
  - 通貨単位が違う場合は例外となる
- 逆に定義されていないふるまいはできないという制約も可能

### 2.5 値オブジェクトを採用するモチベーション

- クラスを増やすことに抵抗を感じる開発者は多いため、値オブジェクトを採用するにはこの心理的ハードルを越える必要がある
- そのためのモチベーションを紹介
  - 表現力を増す
  - 不正な値を存在させない
    - 例外の送出処理をクラス内にまとめられる
  - 誤った代入を防ぐ
    - 自己文書化を進める（コードの正しさをコードで表現する）
    - UserIdにUserNameを代入できないようにする
  - ロジックの散在を防ぐ
    - ルールをクラス内に納められる

## Chapter3 ライフサイクルのあるオブジェクト「エンティティ」

### 3.1 エンティティとは

- 値オブジェクトとの違いは同一性によって識別されるか否か
- 年齢を重ねると人は別人になるか？⇒No
- つまり、属性が同じかどうかではなく、それ以外の何かで同一性が担保されている
- システム管理の文脈では、ユーザ情報を編集しても別のユーザになってしまうことはありえない

### 3.2 エンティティの性質

- 可変である
  - 値オブジェクトは交換により変更を表現していたが、エンティティはそのふるまい（関数）を使って属性を変更する
    - 無味乾燥なget, setも使わない方が良さそう
  - ただし全ての属性を可変にするわけではなく必要に応じて許可されているだけ（限りなく不変が良い）
  - 例外送出はあくまでセーフティネットであり、処理前にチェックすべき
- 同じ属性であっても区別される
  - 値オブジェクトは同じ属性を持っているとおなじものとして扱われるが、エンティティはそうではない
  - 同姓同名は同一人物ではない
  - 見分けるためには識別子UserIdなどが属性に必要
- 同一性を持つ
  - ユーザ名の変更前後で同じユーザとして認識して欲しいはず
  - そのためには識別子を使用して同一性を判断
  - 識別子は同一性の実体であり、その性質から可変にする必要はない
  - 同一性を比較するためのふるまいも必要
- 値オブジェクトでは、全ての属性が比較対象であったが、エンティティでは識別子だけが比較の対象となる

### 3.3 エンティティの判断基準としてのライフサイクルと連続性

- 何を値オブジェクトとし、何をエンティティとするか
- ライフサイクルが存在し、そこに連続性があるかは大きな判断基準
- ユーザは作成されて生を受け、削除されて死を迎える、ライフサイクルを持ち、連続性のある概念
- ライフサイクルや連続性がない、持たせることが無意味そうなオブジェクトは値オブジェクトにする
  - 極力不変なオブジェクトで構成することがセオリー

### 3.4 値オブジェクトとエンティティどちらにもなりえるモデル

- 全く同じ概念をさしていてもシステムによって異なる
  - 車にとってはタイヤはパーツであるため、交換可能であり、値オブジェクトでは
  - タイヤ工場にとっては個体を識別することは重要であり識別子をもつエンティティ

### 3.5 ドメインオブジェクトを定義するメリット

- コードのドキュメント性が高まり、ドメインにおける変更をコードに伝えやすくなる
- このメリットは製造工程よりも、保守開発で際立つ
- 仕様書は残念ながらマクロな要件について有効であり、ミクロな要件については無力であることが多い
- 質の悪いことにドキュメントはコードと異なり、記載内容が間違っていても動作しなくなるような問題は引き起こさない
- ルールがオブジェクトに記載されていない、無口なコードの場合、そこに存在する暗黙のルールが守られているかは全てのコードを洗い出す必要がある。
- これは熟練した開発者であっても多大な労力が必要
- また後からルール変更することも容易

### 3.6 まとめ

- もしエンティティを実装しようとしてそこにあいまいさを感じたのであれば、それはドメインの捉え方を見つめなおすきっかけ

## Chapter4 不自然さを解決するドメインサービス

### 4.1 サービスが指し示すもの

- ソフトウェア開発の文脈では、サービスはクライアントのためになにかを行うオブジェクト
- サービスは多様であり、ドメイン駆動設計においても、ドメインサービスとアプリケーションサービスがある

### 4.2 ドメインサービスとは

- 値オブジェクトやエンティティにふるまいを記述すると不自然となるものを、ドメインサービスで解決する
- 不自然な例
  - ユーザの重複確認

### 4.3 ドメインサービスの濫用が行き着く先

- ドメインオブジェクトが無口となり、クラス定義で意図を読み取ることが不可能となる
- この状態をドメインモデル貧血症という
- すべてのふるまいはドメインサービスに記述できるが、可能な限り避ける必要がある

### 4.4 エンティティや値オブジェクトと共にユースケースを組み立てる

- データストアへの問い合わせは眺めているだけでは意図をすぐには汲み取れない
- またこれらはRDBに依存しており、柔軟性に乏しい（NoSQLに変更を迫られるとコードの大半の変更が必要）
- これを解決するにはリポジトリというパターンが役立つ

### ドメインサービスの基準

- ドメインサービスは入出力を伴う処理を扱わないようにすべきという考えもあり、その意味ではこの実装は間違っている
- しかし筆者としては、可能な限り入出力をドメインサービスで扱わないようにする方針ではあるが、必要とあればいとわない
- より重要視していることは、その振る舞いがドメインに基づくものかそうでないかという点
- それを表現するために、インフラストラクチャのサービスの協力をえることは問題ない

### 4.5 物流システムに見るドメインサービスの例

- Ship, ReceiveはPhysicalDistributionBase(物流拠点を表すエンティティ)のふるまい
- 拠点間の輸送自体はドメインサービス

### 4.6 まとめ

## Chapter 5 データにまつわる処理を分離する「リポジトリ」

- リポジトリはオブジェクトの永続化や再構築を行う
- リポジトリとして分離することでデータストアを差し替え可能にし、テスト実行を容易とし、変更の難易度を下げることにつながる

### 5.1 リポジトリとは

- データの保管庫
- オブジェクトのインスタンスを保存したい場合は直接データストアに書き込みを行うのではなく、リポジトリにインスタンスの永続化を依頼
- 永続化したデータからインスタンスを再構築したい場合は、リポジトリにデータ再構築を依頼

### 5.2 リポジトリの責務

- コードの大半はデータストアの具体的なそうさとなるため趣旨が読み取りづらくなる
- このような具体的でややこしい処理を抽象化して扱うことで趣旨が分かりやすくなる

### 5.3 リポジトリのインターフェース

- インターフェースという抽象型で定義し、Save（永続化）、Find（再構成）などのふるまいをもつ。
- Exist（重複確認）などはリポジトリにやらせない、ユーザの重複確認はドメインのルールに近く、リポジトリは永続化と再構成のみの責務とする
- 「ユーザ名により重複確認をする」というドメイン知識が失われる
- ドメインサービスにインフラストラクチャに関わる処理を書きたくない場合は、重複確認のキーを引き渡すと、ドメイン知識が失われない

### 5.4 SQLを利用したリポジトリを作成

- ビジネスロジックに特定の技術基盤に依存した処理は書くべきではないが、リポジトリの実装は技術基盤に依存した処理を記述しても問題ない。

### 5.5 テストによる確認

- RDBを使ってテストをする場合、テーブルの準備などが煩雑、場合によっては前テストしたデータを削除するなどが必要
- これが極まるとテストをしなくなってしまう。
- 効率的にテストを行う仕組みが必要

### 5.6 テスト用のリポジトリを作成する

- メモリをデータストアとしてインメモリとして動作させる
- たとえば連想配列をベースとしたリポジトリを実装
- 基本的には永続化も再構成もディープコピーで行う（データストアが書き変わってしまうため）

### 5.7 ORMを用いたリポジトリの作成

- SQLを組み立てずORMを使う例

### 5.8 オブジェクトに定義されるふるまい

- 永続化（Save）
  - これはオブジェクト自体の永続化
  - 識別子と更新項目を引き渡して更新させるようなメソッドは適切ではない
  - 同様にオブジェクトを作成する処理もリポジトリには定義しない
- 削除（Delete）
- 再構築（Find）
  - 識別子が基本
  - 探索用に全件（FindAll）が合っても良いが慎重になる必要がある。
  - 探索する際にはそれぞれに適したメソッドがあると良い
    - FindByUserNameなど

### 5.9 まとめ

- 特になし

### Chapter6

### Chapter7

### Chapter8

### 8.3 MVCフレークワークに組み込んでみよう

- ASP.NETが分からないので正直完全な理解は難しい
- 他のフレームワークで置き換えて理解する必要がある
- コンストラクタで依存性の解決がされている
- ビジネスロジックをアプリケーションサービスに寄せることで、コントローラとしてのコードはほとんど同じような記述にシンプルなものとなる点はポイント

### コントローラの責務

- コントローラの責務は入力の変換をしてモデルに伝えること（ゲーム機のコントローラの電気信号への変換と同じ）
- コントローラがそれ以上のことをこなしている場合は、ドメインの重要な知識やロジックがコントローラに漏れだしている可能性を疑うべき

### 8.4 ユニットテストを書こう

- 結果の確認に必要なアクセスをリポジトリが提供しているとは限らないため、テスト用のImMemoryRepositoryはリポジトリのプロパティを直接操作可能にしておくとよい。
- ドキュメントが一切存在しないプロダクトにおいては、ユニットテストがそのロジックのあるべき姿を語る最後の手がかり

### 8.5 まとめ

- 特になし

## Chapter9 複雑な生成処理を行う「ファクトリ」

---
2023-04-24 : 51/341 (15.0%)
2023-05-02 : 79/341 (23.2%)
2023-05-03 : 108/341 (31.7%)
2023-05-04 : 171/341 (50.1%)
2023-05-05 : 187/341 (54.8%)
