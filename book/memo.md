
###Chapter5４つの基本的なチームタイプTheFourFundamentalTeamTopologies

>・ストリームアラインドチーム
>・イネイブリングチーム
>・コンプリケイテッド・サブシステムチーム
>・プラットフォームチーム
>
>中規模な組織や大規模な組織では、基本的なチームタイプそれぞれに１つ以上のチームが存在するだろう。
>特に、ストリームアラインドチームは複数あることが普通だ（本章で見ていく）。
>だが、複数のプラットフォームチームがあったり、異なる目的ごとにいくつかのイネイブリングチーム（たとえば、CI/CD担当のチームとインフラストラクチャー・アーキテクチャー担当のチーム）があったりする組織もある。
>ある。どうしても必要な場合は、コンプリケイテッド・サブシステムチームが１～２チーム存在する場合もある。

コンプリケイテッド・サブシステムチームが複数なのはまれ？

>基本的なチームタイプには、運用チームもサポートチームも含まれていない。これは意図的だ。
>長続きするチームがシステムを構築する。そしてそのチームは、構築したシステムの実際の運用の非常に近くにいる。
>ストリームアラインドチームは、継続的デリバリーや運用性のような良いソフトウェアデリバリーのプラクティスに従う。
>そして、ほとんどコードを書かなかったとしても、実際の運用にも責任を負うのだ。

運用もサポートもストリームアラインドチームの領分

####ストリームアラインドチーム

>ストリームアラインドチームとは、価値のある単一の仕事のストリームに沿って働くチームのことだ。
>ストリームとは、仕事やサービスの場合もあるし、機能一式のこともあり、ユーザージャーニーやユーザーペルソナの１つのような場合もあるだろう。
>さらに、なるべくそのチームだけですばやく安全に顧客やユーザーに価値を届けられるように、チームに権限が委譲されている。
>他のチームへの仕事の引き継ぎは必要ないということだ。

この世界では大規模な開発は存在しない？

>残りの基本的なチームタイプの目的は、ストリームアラインドチームの負荷を減らすことにある。
>たとえばイネイブリングチームのミッションは、ストリームアラインドチームが欠いている能力をすばやく獲得するのを助けることにある。
>プラットフォームチームのミッションは、下位の詳細な知識（プロビジョニング、監視、デプロイなど）を引き取り、使いやすいサービスを提供することでストリームアラインドチームの認知負荷を減らすことだ。

>ドン・レイネルトセンの言葉を借りれば、「大きなチームより、スキルの高い人からなる小さなチームのほうが、本番環境での方針変更をすばやくできる」

>組織のなかでは複数のストリームが共存できる。
>特定の顧客向けのストリーム、ビジネスエリアごとのストリーム、地理的ストリーム、プロダクトストリーム、ユーザーペルソナストリームなどがあり、規制の多い業界であればコンプライアンスストリームさえある
>（さまざまなストリームでの仕事を整理する方法については、Chapter6を参照）。

>どのようなストリームでも、ストリームアラインドチームは、短期のプロジェクトではなく、長期的に維持される仕事のポートフォリオもしくはプログラムの一部として、予算が割り当てられる。

なるほど

>モダンなソフトウェア組織では、ほとんどのチームがストリームアラインドチームとなる。

>CEOジェフ・ベゾスの厳命により、Amazonのサービスやアプリケーションを担当するチームは、真に独立していることが求められた。

ある意味、チームトポロジーはAmazonっぽい話をずっとしていると感じる

>他のチームのサービスやアーキテクチャー、利用技術に干渉してはいけないし、いかなる前提も設定してはいけない

コレのせいで統一性がない部分はあるんよな

>サービスチーム間の調整はほとんどない。結果として、高度に分散し、多種のスタックからなるマイクロサービスになっていった。
>おもしろいことに、テストは例外だった。テスト担当ソフトウェア開発エンジニア（SDET）が組織全体を横断して働き、良いテストプラクティスとツールをチームに勧める活動を行った
>（日々のテスト実施の役割はそれでも個々のチームが担当する）。

>●ストリームアラインドチームが備える能力

>Googleが先駆けとなったサイトリライアビリティエンジニアリング（SRE）チームは、実際にはストリームアラインドチームの一種で、本番環境での大規模なアプリケーションの信頼性に責任を負う。
>SREチームは、アプリケーションを開発する単一もしくは複数のストリームアラインドチームとコラボレーションし、ソフトウェアの変更がストリームに適切に沿ったものにする。

ストリームアラインドチーム同士もコラボレーションするという話か？

>●「プロダクトチーム」や「フィーチャーチーム」でなく、なぜストリームアラインドチームなのか？

>このように複数チャネルと高度に結合されたコンテキストでは、「プロダクト」はいろいろな意味を持つ。これが「プロダクトチーム」の責任範囲を理解し難くしている。
>たとえば製造業でプロダクトといえば、使用期間が定められた物理的なデバイスだろう。
>エンジニアリングチームが何年もかけて開発し、プロダクトが廃番になればチームは解散させられる。

>ストリームアラインドという用語は、「プロダクト」や「フィーチャー」よりも幅広い状況に対応できるだけでなく、ストリームに沿ったフローの強調という意味もある。

>●期待されるふるまい

>ストリームはビジネスドメインに関連することが多いが、そうでない場合もある。

具体的によくわからなかった

####イネイブリングチーム

>イネイブリングチームは、特定のテクニカル（プロダクト）ドメインのスペシャリストから構成され、能力ギャップを埋めるのを助ける。
>複数のストリームアラインドチームを横断的に支援し、適切なツール、プラクティス、フレームワークなどアプリケーションスタックのエコシステムに関する調査、オプションの探索、正しい情報に基づく提案を行う。

>イネイブリングチームの最終的なゴールは、ストリームアラインドチームへのソリューションの提供ではない。
>ストリームアラインドチームの課題に注力することで、ストリームアラインドチームの自律性を高めることである。

このさじ加減がむずかしい

>ストリームアラインドチームは、イネイブリングチームからの支援を数週間から数か月で必要としなくなるはずだ。
>イネイブリングチームへの継続的な依存関係は作るべきではない。

>特定のクライアント技術（デスクトップ、モバイル、ウェブなど）のビルドエンジニアリング、継続的デリバリー、デプロイ、テスト自動化などだ。

>●期待されるふるまい

>イネイブリングチームのミッションは、ストリームアラインドチームがその時点で持っていない必要な能力を獲得するのを助けることだ。
>通常は、特定の技術領域やプロダクトマネジメント領域に関わることが多い。

>イネイブリングチームが存在するのは、ストリームアラインドチーム内の不適切なプラクティス、優先順位設定の間違い、品質の低いコードなどに起因する問題を解決するためではない。
>ストリームアラインドチームがイネイブリングチームとコラボレーションするのは、新しい技術、コンセプト、アプローチについての能力を高めるためであり、短期間（数週間から数か月）にとどめるほうがよい。

そうなの？よくわからんな。

>●イネイブリングチームとコミュニティオブプラクティス（CoP）

CoP知ってる前提で書かれてもわからん

####コンプリケイテッド・サブシステムチーム

>コンプリケイテッド・サブシステムチームは、システムのなかでスペシャリストの知識が必要となるパーツを開発、保守する責任を持つ。
>ほとんどのチームメンバーがその分野のスペシャリストでなければ、理解や変更が難しいようなサブシステムを担当する。
>このチームの目的は、複雑なサブシステムを含んだり利用するシステムの担当となるストリームアラインドチームの認知負荷を減らすことにある。

>考えられるサブシステムの例としては、動画処理コーデック、数理モデル、リアルタイム取引裁定アルゴリズム、金融サービスのトランザクションレポートシステム、顔認識エンジンなどがある。

いまどき自分から作ることはないのではー…
著者が理解できてないものを勝手にサブシステムに入れているだけな気がする。発想が安易な気がする。

>複数のシステムで共有するサブシステムが見つかった場合に作られるようなコンポーネントチームと、コンプリケイテッド・サブシステムチームの決定的な違いは、
>サブシステムに特別な専門知識が必要である場合にのみ作られることにある。
>判断基準はチームの認知負荷だ。コンポーネントの共有可能性ではない。

####プラットフォームチーム

>プラットフォームチームの目的は、ストリームアラインドチームが自律的に仕事を届けられるようにすることである。
>プラットフォームチームは、内部サービスを提供することで、ストリームアラインドチームが下位のサービスを開発する必要性をなくし、認知負荷を下げる。

>プラットフォームチームは、少数のサービスを高い品質で提供することに集中するのが現実的だ。多数のサービスを提供していても、品質やレジリエンスの問題だらけでは話にならない。

>商用のプロダクトと同じように、プラットフォームでも複数のサービルレベルを提供できる。

>どこまでをプラットフォームとするかの境界には大きな幅がある。
>厚いプラットフォームでは、複数の内部プラットフォームチームが無数のサービスを提供していることもある。
>薄いプラットフォームでは、単にベンダーのソリューションに皮をかぶせただけの場合もある。
>良いプラットフォームの構成要素については本章の後半で議論する。

>●他の基本的なチームタイプでプラットフォームを構成する

>大規模な組織では、プラットフォームの開発と運用が単一のチームでは足りないことがある
>このような状況では、基本的なチームタイプ（ストリームアラインドチーム、イネイブリングチーム、コンプリケイテッド・サブシステムチーム、プラットフォームチーム）の集合がプラットフォームを形成する。
>だが、プラットフォームチームが方向をそろえるストリームは、売上を生み出したり顧客に直接触れたりするメインのプロダクトやサービスのストリームではない。
>プラットフォームでは、ストリームはプラットフォーム内のサービスやプロダクトに関連するものになる。

>結果として、プラットフォーム内に入れ子構造もしくは「フラクタル」構造のチームが生まれる。
>これを私たちは、内部トポロジーと呼ぶことにした。

####変更フローのなかでチームサイロを避ける

>ソフトウェアを速く安全に届けたいなら、単一職能からなるチームは避けるべきだ。
>これまで、多くの組織は単一職能からなる島や「サイロ」を作ってきた。

>安全で速い変更フローに最適化された組織では、多能工型または職能横断型チームを変更のフローに沿って配置することが多い。
>私たちが、ストリームアラインドチームと呼んでいるチームだ。

####良いプラットフォームは「ちょうどよい大きさ」

>しかし、極めて多いのがプラットフォームの開発と運用を、以前システム管理者だった人たちにそのまま一任することだ。
>そこでは、アジャイルプラクティス、テスト駆動開発、継続的デリバリー、プロダクトマネジメントなどの適切なソフトウェア開発テクニックは使われない。
>組織から予算を割り当てられることもなければ、注意を向けられることもない。こんなプラットフォームでは、他のチームの助けになるどころか、足を引っ張ってしまう。

ありそう

>●最低限のプラットフォーム

>いちばんシンプルなプラットフォームは、下位のコンポーネントやサービスについて書いた単なるWikiページ上のリストだ。

Notionをメンテするのもプラットフォームチーム風ってことかな

>どんな場合でも、最低限のプラットフォーム（TVP＊5）を目指すべきだ。プラットフォームが制約になるのは避けなければいけない。

>●認知負荷の低減とプロダクト開発の加速

>●一貫性と説得力を併せ持つ適切なプラットフォーム

>プラットフォームの開発で陥ることが極めて多い落とし穴は、チームのニーズと切り離してしまうことだ。
>プラットフォームチームは、ユーザーエクスペリエンス（UX）、とりわけデベロッパーエクスペリエンス（DevEx）にフォーカスする必要がある

繰り返し言ってますね

>プラットフォームについてのフィードバックをプラットフォーム開発者に返す道筋が必要だ。
>さもないと、プラットフォームは会社の他の部分から孤立してしまう。

>●下位のプラットフォーム上に作る

>哲学的な表現をすれば、「下には常に亀がいる」だ。

そうだな

>●稼働中のプロダクトやサービスのように管理する

>プラットフォームにも、プロダクトマネジメントの実践者が整理したロードマップが必要だ。

####これまでのチームを基本的なチームタイプに変換する

>実は、４つの基本的なチームタイプをチームに割り当てるだけで、ほとんどの組織では大きな効果が得られる。
>チームがどのチームタイプになるかを認識することで、チームの最良の働き方を理解し、トポロジーのパターンにしたがって目的とふるまいを変えていけるようになるからだ。

収益に責任を持つのはどの部署だ？ストリームアラインドチーム？

>●ほとんどのチームを長続きする柔軟なストリームアラインドチームにする

>ほとんどのチームは、多能工で構成され長続きするストリームアラインドチーム

>●インフラストラクチャーチームをプラットフォームチームにすべきだ。

>インフラストラクチャーチームをプラットフォームチームに変換するのは、シンプルでも簡単でもない。
>プラットフォームは実績のあるソフトウェア開発テクニックを使って管理すべきプロダクトであって、インフラストラクチャー担当の人間にとっては極めて馴染みの薄いものだからだ。
>だが、本章にあるさまざまな例からもわかるとおり、このアプローチはうまくいく。

ほんとぉ？

>●コンポーネントチームをプラットフォームチームもしくは別の種類のチームにする

>技術コンポーネントに基づくチームは、解散して仕事をストリームアラインドチームに引き渡すか、もしくは別の種類のチームに変える必要がある。

>コンポーネントが下位の「プラットフォーム」コンポーネントであれば、プラットフォームチームに合流させるとよい。
>ストリームアラインドチームがコンポーネントを簡単に扱えるなら、技術コンポーネントにもとづくチームをイネイブリングチームにしてもいいし、
>ストリームアラインドチームが扱うには複雑すぎるのであれば、コンプリケイテッド・サブシステムチームにするのもよいだろう

各チームの位置づけが分かる

>ストリームアラインドチーム以外のチームの数は、ストリームアラインドチームの７分の１から10分の１にすぎない。
>成功している組織についての報告を踏まえると、ストリームアラインドチームとそれ以外のチームの数の比は、６：１から９：１になるのが適切だろう。

一つの基準

>たとえば、データベース管理チームは、ソフトウェアアプリケーションレベルの仕事を止め、データベースのパフォーマンス、
>モニタリングなどの知見をストリームアラインドチームに広める活動にフォーカスすることで、イネイブリングチームになれる。

これは分かりやすい

>●ツールチームをイネイブリングチームもしくはプラットフォームチームの一部にする

>ツールチームは、明確な目的を設定した短期間のイネイブリングチームとして運営するか、明確なロードマップを持つプラットフォームチームの一部として運営するほうがよい。

>●サポートチームを変換する

>これまで多くの組織はサービス横断的な単一のチームを割り当てて、稼働中の環境のアプリケーションやサービスのサポートを提供していた。

>だが、ソフトウェアシステムが常に激しく変化する状況において、変更フローをより安全に速くするため、成功している組織はサポートチームの構成と配置を見直し始めている。

>問題がストリームエリア内にとどまるものであれば、他のチームを巻き込む必要はない。必要に応じて、他のサポートチームを招集して問題を分析する。
>インシデントが多数のチームに影響するのであれば、いろいろなサポートチームからスペシャリストが集まって動的な「スウォーム」もしくは「インシデントスクワッド」を組織し、
>問題の選別や早急なサービスの回復を目指す

サポートチームの動きは少し複雑な印象を受けた

>●アーキテクチャーとアーキテクトを変換する

>アーキテクチャーチームが必要な場合、最も効果的に使えるパターンは、パートタイムのイネイブリングチームだ。パートタイムにすることが重要だ。
>多くの判断は実装チームが行うべきで、アーキテクチャーチームが行うべきでないことを明確にするためである。

おもしろい

>他のチームのメンバーを集めてバーチャルチームを構成している組織もある。
>このバーチャルチームは定期的に集まり、システムのアーキテクチャーの進化について議論する。Spotifyが使うギルドやチャプターとよく似ている（

なるほど

>重要なのは、モダンなソフトウェア開発において、アーキテクチャーチームは、他のチームに設計や技術選択を強制するのではなく、
>他のチームが効果的に働けるようにサポートするチームであるべきということだ。

技術選定の標準化と関わりそう

>アーキテクチャーにフォーカスしたパートタイムのイネイブリングチームの重要な役割は、コンウェイの法則を考慮しつつ
>チーム間の効果的なAPIを発見し、チーム対チームのインタラクションの形を設計することである

別途Chapter7で扱うらしい

####まとめ疎結合でモジュラー化された４つのチームタイプを使う

##Chapter6チームファーストな境界を決める

>だが、多くの組織がチームの責任境界に大きな問題を抱えている。
>チームの適切な境界について考慮されることはほとんどなく、オーナーシップの欠如、エンゲージメントの低下、デリバリー速度の極端な低下といった結果を招いている

>本章では、ソフトウェアシステム内もしくはソフトウェアシステム同士の適切な境界を定義し、それを掘り下げていく。

>境界はチームのサイズにあったものであることが極めて重要だ。
>ソフトウェアとシステムの境界を個々のチームの能力にあったものにすることで、オーナーシップとソフトウェアの持続的な進化がより現実的なものになるのだ

>チーム間の責任の境界を注意深く探って検証し、ドメイン駆動設計や「節理面」のようなテクニックを活用することで、
>ソフトウェアアーキテクチャーを問題ドメインに合わせ、変更フローが速く流れるようにし、社会工学的システムをよりすばやく効果的に進化させる能力を組織に提供する。

社会工学はよくわからないけど、節理面はよく聞きますね。

####ソフトウェアの責任と境界に対するチームファーストのアプローチ

>ソフトウェアのデリバリーにおける多くの問題は、チーム間の境界とチームごとの責任が誤って不明瞭になったことに起因する。

>この問題は、コンウェイの法則のとおり、（たとえドキュメントでは、アーキテクチャーが高度にモジュール化されていて、拡張可能だとされていても）
>パーツ間の結合度が高いソフトウェアとなって現れることが多い。一般的に、このようなシステムを「モノリス」と呼ぶ。

ここは本当にそうかな？という感じ。まだ完全には納得がいかないのよなー。

>「目指すべきは『〈チーム間のコミュニケーションをさほど要さずに、設計からデプロイまでの作業を完遂できる能力〉を促進するアーキテクチャを生み出すこと』なのである。
>この戦略を可能にするアーキテクチャ面でのアプローチとしては『コンテキスト境界とAPIにより、大規模なドメインを、より小規模、より疎結合なユニットに分割する』（中略）などが挙げられる」

LeanとDevOpsの科学からの引用。

>チームのことを考慮に入れないで進めると、モノリスを間違った形で分割したり、サービス同士の依存性が高い複雑なシステムを作り出したりするリスクがある
>これは「分散モノリス」と呼ばれ、すべての変更で他のサービスの更新が必要となり、サービスの自律性を欠く。

なるほど

####隠れモノリスと結合

>モノリシックなソフトウェアにはさまざまな種類のものがあり、そのなかには最初に見つけるのが難しいものもある。

モノリスにも種類がある

>●アプリケーションモノリス

>アプリケーションモノリスは多くの依存関係や責任を持つ単一かつ巨大なアプリケーションで、多くのサービスやさまざまなユーザージャーニーを外部に公開しているものである。
>このようなアプリケーションは単一のものとしてリリースされるのが普通で、頭痛のもとになる。ユーザーはデプロイの間アプリケーションを使えない。
>運用担当者は、本番環境が安定せず予期せぬ問題に悩まされる。
>たとえそのモノリスを疑似本番環境でテストしていたとしても、そのあとに変わってしまっているためだ。

>●データベース結合モノリス

>データベース結合モノリスは、同一のデータベーススキーマと結合している複数のアプリケーションやサービスから構成されており、それぞれ別々に変更、テスト、デプロイするのが難しい。
>これは、組織がサービスではなくデータベースをコアのビジネスのエンジンだと考えている場合に発生することが多い。
>１つか複数のデータベース管理チームがあり、データベースの維持だけでなく、変更の調整も行うのが一般的だ。人手が不足していることが多く、彼らがデリバリーにおける大きなボトルネックになる。

>●モノリシックビルド（すべてをリビルド）

>モノリシックビルドでは、コンポーネントの新バージョンのために、単一の巨大な継続的インテグレーション（CI）でビルドを行う。
>アプリケーションモノリスがモノリシックビルドをもたらすが、小規模なサービスでも同じ問題は起こりうる。
>コンポーネント（パッケージやコンテナ）間の依存関係を管理する標準的な仕組みを使うのではなく、コードベース全体をビルドするようなビルドスクリプトになっているような場合だ。

>●モノリシックリリース（すべてをまとめてリリース）

>モノリシックリリースは、小さなコンポーネントをまとめて「リリース」する。
>コンポーネントやサービスはCIで独立してビルド可能でも、サービスのモックは使わず共有の固定環境でしかテストできない場合、
>全コンポーネントの最新バージョンをまとめて同一の環境に導入することになる。

モック化も大事？

>●モノリシックモデル（画一的な視点）

>モノリシックモデルとは、単一のドメイン言語と表現（フォーマット）を多くのさまざまなコンテキストに強制的に適用しようとするソフトウェアのことだ。

>●モノリシック思考（標準化）

>モノリシック思考とはチームの「画一的」な考え方のことで、技術面やチーム間の実装アプローチにおける不要な制約を生み出す。
>ばらつきを最小限にするために何でも標準化すると、エンジニアリングチームの管理は楽になるが、これはとてもコストがかかる。
>優れたエンジニアは新しいテクニックや技術を学習できるし、学習したがっている。
>単一の技術スタックやツールを強制し、チームの選択の自由を奪うと、仕事で適切なツールを使う能力に大きな悪影響を及ぼし、モチベーションを阻害したり、ときにはモチベーションを消し去ったりしてしまう。

これむずいなー。
議題候補★

>●モノリシックワークスペース（オープンプランオフィス）

>モノリシックワークスペースとは、地理的に同じ場所にいるすべてのチームや個人に適用する単一のオフィスレイアウトのパターンのことだ。

>オープンプランオフィスがコラボレーションを促進するという通説もある。だが、採用した２つの組織での調査の結果、それは否定されている。
>対面でのやりとりが大幅に減少（約70%）し、それに伴って電子的なやりとりが増加したのだ［111］。
>必要なのは、いる場所を同じにするだけでなく、目的を同じにすることである。

理由がわからないなー。どういうことだろう。
目的を同じにすることが大事なのは分からなくもない。
議題候補★

####ソフトウェアの境界、または「節理面」

>いずれの種類のモノリスにもデメリットがあるが、ソフトウェアを複数チーム間で分割する場合にも、注意しなければいけない危険なポイントがある。
>ソフトウェアを分割すると、分割後のパーツ間で一貫性が減り、複数のサブシステム間で誤ってデータの重複を起こす可能性があるのだ。

>まず理解しなければいけないのは、節理面とは何なのかだ。
>節理面は、ソフトウェアシステムを簡単に複数に分割できる自然な継ぎ目のことだ。

>伝統的な石工は、石を特定の角度で叩き、自然の節理面を利用して岩をきれいな断面で分割していく。
>ソフトウェアでも同じような節理面を探せば、ソフトウェアの境界となるような自然な分割点が

たとえは分かりやすいんだが、節理面は経験によって見えてくるもの？
議題候補★

>通常は、ビジネスドメインの違いとソフトウェアの境界を合わせるのが最善だ。
>モノリスは技術的な観点で見ても問題が多い。

これじゃ具体的に分からないｗｗ
議題候補★

>だが、ビジネスドメイン以外にも、ソフトウェアでは複数の節理面の候補がある。
>私たちは、さまざまな節理面を組み合わせることで、モノリスを分割していくべきだし、そうすることが可能だ。

>●節理面：ビジネスドメインのコンテキスト境界

>ほとんどの節理面（ソフトウェアの責任境界）はビジネスドメインで境界づけられたコンテキストに合わせるべきだ。
>境界づけられたコンテキストとは、大きなドメインモデルやシステムモデルを小さなパーツに分割する単位のことで、それぞれ内部的には一貫したビジネスドメイン領域を表している（

この辺はDDD読んでないとツラいな
参考
-[境界づけられたコンテキスト概念編-ドメイン駆動設計用語解説[DDD]-littlehands'lab](https://little-hands.hatenablog.com/entry/2017/11/28/bouded-context-concept)
議題候補★

>書籍『DesigningAutonomousTeamsandServices』のなかで、DDDの専門家ニック・チューンとスコット・ミレットはオンライン音楽ストリーミングサービスを例に挙げている。
>このサービスは、メディアディスカバリー（新曲を見つける）、メディアデリバリー（リスナーに音楽を届ける）、ライセンス（権利管理とロイヤリティの支払い）という３つのサブドメインを持ち、
>ビジネスに沿ったものににあっている

これは分かりやすい例かも
議題候補★

>境界づけられたコンテキストを特定するには、多くのビジネス知識と技術的な専門知識が必要だ。そのため、最初は間違いやすい。
>だが、コンテキストを深く理解できるようになったら、改善や適応に躊躇してはいけない。サービスの再設計の「コスト」が繰り返しかかってくるような状況であってもだ。

わかるんだが、現実は厳しいよ
議題候補★

>DDDを適用する他の利点としては、あるビジネスドメインの境界づけられたコンテキストにおいて、中心にある複雑性と機会に集中できること、
>考えるべきドメインが小さくなったため、ビジネスエキスパート同士のコラボレーションによってモデルを探索できること、
>これらのモデルを明示的に表現するソフトウェアを作れること、ビジネスオーナーとエンジニアの双方が境界づけられたコンテキストのなかで、
>ユビキタス言語を話せるようになることが挙げられる

こんな理想的な状態をまだ見てないのだ…

>●節理面：規制遵守

>金融業界や医療業界のように規制の厳しい業界では、規制の要件がソフトウェアにおける厳しい境界になることが多い。
>規制によって、クレジットカードの決済や取引報告などのソフトウェアの監査、ドキュメント、テスト、デプロイにおいて、組織が特定のメカニズムを採用するように求められるのだ。

これはあるかもですね

>システムの重要でない領域まで厳しい要求の遵守を求めるべきではない。
>規制の対象となるモノリスをサブシステムに分割したり、フローを分離したりするのが、自然な節理面となる。

これは納得感がある

>PCIDSSへの準拠はカードデータ管理用のサブシステムだけに適用すべきであって、この要求は支払い機能を含むモノリス全体に適用すべきものではない。
>規制遵守という節理面に沿って分割することで、監査とコンプライアンスが容易になり、監視の範囲を減らすことができる。

>●節理面：変更のケイデンス

>もう１つ別の節理面は、システムのなかで違う頻度で変更が必要になるところだ。
>モノリスの場合、全体の速度は、いちばん遅い部分の速度になる。

>システムを変更の速度が違うところで分割することで、すばやく変更できるようになる。
>モノリスが全員に固定の速度を強いるのではなく、ビジネスニーズが変更の速度を決められるようになるのだ。

そっすね

>●節理面：チームの地理的配置

>分散チームでは、コミュニケーションが制限される。
>地域をまたがってコミュニケーションするには、物理的もしくは仮想的な場所と、時間を明示的に要求しなければいけないからだ。

そうですね。

>あらかじめ決めていない、それ以外のチームコミュニケーションは全体の80%を占めることもあり、それは各チームのパーティションで囲まれた物理的な境界のなかで発生する。

どういう意味？

>リモートワーカーが避けられないなら、チーム内やチーム間のコラボレーションを育みコミュニティを作るために、追加の仕事が必要になる。
>可能な限り異なるタイムゾーンを含めず、同一のタイムゾーン内に限るようにするのだ。
>異なるタイムゾーンの人を含めてしまうと、自宅での個人的な時間を侵害してしまうことになり、お互いに会いたがらないようになってしまうからだ［116］。

厳しめの意見ですね

>チームが効率的にコミュニケーションするためのオプションは２つだ。
>１つは、チームメンバー全員が同じ物理スペースを共有する形で、同じ場所にいること。
>もう１つは、完全なリモートファーストのアプローチだ。

ハイブリットだとコミュニケーションに差が出てしまう？

>このどちらも実現できない場合は、モノリスを別々のロケーションのチーム用のサブシステムに分割するのがよい。

>●節理面：リスク

>多くのリスクを取るというのは、システムやアウトカムの失敗確率が高くても、変更をすばやく顧客に届けるのを優先することを意味する。
>余談だが、モノリスではなく疎結合のシステムアーキテクチャーのもとで継続的デリバリーが本当に実現できていれば、
>小さな変更を頻繁にデプロイするリスクは実際に減少する。

>無料でも使える人気機能に対する変更は、高リスクプロファイルとなり、大きな失敗は数百万人の潜在有償ユーザーを失うことを意味する。
>有償ユーザーのみが利用可能な機能に対する変更は、障害が発生したときにこの数百人に対するサポートの速度に問題がなく、個別対応でも対処できるのであれば、現実的には低リスクを維持できる。

面白いな
議題候補★

>●節理面：パフォーマンスによる分離

>特定のパフォーマンス要求に基づいてサブシステムに分割することで、サブシステムが自律的にスケールできるようになり、パフォーマンスが向上するとともにコストが下がる。
>納税申告のアプリケーションの構成要素の１つとして、たとえば、パフォーマンス重視の申告と検証のサブシステムがあり、短時間で数百万の申告を扱う。
>税額シミュレーション、処理、支払いのようなサブシステムは、そこまでの性能がなくても稼働できる。

うーむドメインに関連がありそう

>●節理面：技術

>歴史的には、チーム分割の境界に技術だけが使われることが多かった。
>フロントエンド、バックエンド、データ層などでチームを分けるのがどれだけ多いか考えてみてほしい。
>だが、一般的でもある技術主導での分割は、往々にしてさらなる制約を生み出し、フローを改善するどころかフローを低下させる。

技術主導はアンチパターンなのかな

>技術に基づいてサブシステムに分割するのが効果的な場合もある。
>古いシステムや自動化しにくい技術の場合は特にそうだ。
>このような古い技術を含んだ変更が必要な場合、フローは大幅に遅くなる。
>手作業でのテストがたくさん必要だったり、ドキュメント不足や最新の技術スタックでは当たり前のオープンなユーザーコミュニティがないことで変更箇所の実装が難しかったりするためだ。

どういう分野だろう。
議題候補★

>●節理面：ユーザーペルソナ

>複数の料金プランを持つプロダクトでは、設計の段階でどの料金プランでどの機能群を使えるかを決める。

>このような状況だとユーザーペルソナをもとにサブシステムに分割するのは理にかなっている。

>●特定の組織や技術にとって自然な節理面

>ある節理面が適用可能かどうかを判断するリトマス試験紙が必要なら、結果として得られるアーキテクチャーが、
>多くの自律的なチーム（依存度の低いチーム）の支えとなって認知負荷が減るか（責任範囲が分解されているか）どうかを確認しよう。

>もちろん、このような結果を達成したければ、最初に実験したり微調整したりする必要がある。まず実際に試してみないと、具体的な最終結果を保証することなどできない。
>システムとチームの境界を評価するのに役立つ簡単な方法は、単純に「チームは、このサブシステムをサービスとして効果的に利用したり提供したりすることができるか？」と聞いてみることだ。
>答えがイエスなら、そのサブシステムは分割してチームに割り当てて、進化させていくのにふさわしい候補となる。

一つの基準
議題候補★

>CASESTUDYPoppuloにおける適切なソフトウェア境界の発見

>チームでアプローチするようになり、ペアワーク（のちにモブワーク）のようなプラクティスを導入することで、
>チームメンバーが協力してタスクを終わらせるようになり、フローがよくなり始めた。

ええな
議題候補★

>そこで、「マトリクスプロダクトチーム」と呼んでいる職能横断型チームを作り、同じ場所に集まって座り、プロダクトのある領域のオーナーシップを完全に持つようにした。
>プロダクトチームは通常、４人の開発者、１人のプロダクトマネジャー、QA、UX/UIデザイナーで構成する。

これがストリームアラインドチームかな

>私たちはビジネスコンテキストにおけるドメインを理解しモデリングするために、イベントストーミングなどのDDDのテクニックを活用している。
>技術的には、サービスやチーム間のコミュニケーションのコントラクトテストを実現するのにPactを使っている。

聞きなれない単語

####実例製造業

>節理面としてむやみに技術を使うべきではなく、使うとしても、現在のソフトウェアスタックとは感覚や動作が
>大きく異なる古い技術に対して使う場合に限られる、という点をここまで強調してきた。
>だが、何事にも例外はある。難しいのは、例外が有効な場合と、すばやく進めるための簡単な方法が最終的に制約となってしまう場合を見分けることだ。

せやねんな

>ストリームアラインドチームがモバイルアプリケーション、クラウドの処理、デバイス用の組み込みソフトウェアをまたがる
>エンドツーエンドのユーザーエクスペリエンスをすべて担当するのは極めて難しい。
>３つのまったく異なる技術スタック（組み込み、クラウド、モバイル）をまたがるエンドツーエンドの変更には、さまざまなスキルの組み合わせが必要だ。

結論としては難しいね

####まとめチームの認知負荷に合わせてソフトウェア境界を選ぶ

>「マイクロサービスでも、リリース前にそれらの組み合わせでエンドツーエンドのテストが必要なら、それは分散型モノリスだ」

リリースまで独立したプロセスを経られなければモノリスということか
APIをしっかり決めたとして、あるサービスを使う側（クライアント側）であれば成り立つだろうが、逆の互換性を保証するのは難しそうだな
議題候補★